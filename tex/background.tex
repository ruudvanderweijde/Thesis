\documentclass[../main.tex]{subfiles}
\begin{document}
    \chapter{Background and related work}\label{ch:background}
    Chapter \ref{ch:background} describes seven important language constructs which you need to understand in order to understand the difficulties of analysing PHP in section \ref{sec:background_language-constructs}.
    The second section, section \ref{sec:background_annotations}, gives an introduction to the syntax and usage of annotation in PHP.
    Section \ref{sec:background_rascal} explains the programming language \Gls{Rascal} which is used for analysis.
    $M^3$ is a programming language independent meta model which holds various facts about programs. $M^3$ is described in more details in section \ref{sec:background_m3}.
    Section \ref{sec:background_type-system} gives an introduction to type systems and how they are related to this research.
    The final section of this chapter, section \ref{sec:background_related-work}, describes the related work and how these researches are related to this thesis.

    \section{PHP Language Constructs}\label{sec:background_language-constructs}
    This section presents for this research important language constructs and why these constructs are important.
    Explanations of these constructs help you to understand the performed analysis.
    The discussed parts are scoping, includes, conditional classes and functions, dynamic features, late static binding, magic methods and dynamic class properties.
    
    \paragraph{Scoping}
    In PHP, all classes and functions are globally accessible once they are declared.
    All classes and functions are implicitly public, inner classes are not allowed, and conditional functions (see paragraph about conditional classes and functions) will be available in the global scope.
    If a class or function is declared inside a namespace, their name is prefixed with the name of the namespace.
    \\
    Variables have three scope levels: global-, function-, and method-scope.
    Under normal circumstances when a variable is declared inside a function or method, their scope is limited to this function or method.
    Variables declared outside function or methods are available in the global scope, but not in the method or function scope.
    There is an exception for some predefined global variables which are available everywhere. 
    Examples are \texttt{\$GLOBALS}, \texttt{\$\_POST}, and \texttt{\$\_GET}. 
    Variables inside a function or method can be aliased to a global variable by adding the keyword \texttt{GLOBAL} in front of the variable name.
    The variable are then linked to the global variable in the symbol table\footnotemark.
    \footnotetext{http://php.net/manual/en/language.variables.scope.php, July 2014}
    \\
    Closures (anonymous functions in PHP) have the same scoping rules as variables, but they can inherit variables from outside their scope by providing them in the use statement. 
    In this research we will not support closures. 
    
    \paragraph{Includes}
    In PHP it is possible to include other PHP-files during execution of the program. 
    These files will be loaded inline. 
    This means that if you use an include in the middle of a file, the source code of this file will be inserted virtually at that place.
    In this research we will not perform an include analysis.
    Instead we will assume that all files in the project are included during execution. 
    %We have checked all projects for duplicate classes and functions but we have found none.
    %Therefor we assume that this does not effect the outcome of the analysis.
    %It is not known if there are effects on inline includes that we do not cover.
    \\
    According to the coding standard that is used in the php community\footnotemark, function- and class-name classes should not appear when using namespaces and autoloading.
    \footnotetext{http://www.php-fig.org/psr/psr-0/, July 2014}
    When a class which is not loaded in memory is instantiated, the autoloading will try to include a file and load the class.
    The structure of the autoloading is meant to include classes, interfaces, traits and functions and should not have inline code executions which would lead to side-effects.
    
    \paragraph{Conditional classes and functions}
    Once a file is included in the execution, al the classes and functions in the top scope are declared.
    All class and function declarations within condition statements or within a method or function scope are only declared when the code is executed.
    \\
    An example of an conditional statement can be found in listing \ref{lst:conditionals1}.
    If the class \texttt{Foo} or function \texttt{bar} to not exist before the statements is executed, then the class and function will not yet declared. 
    When you try to use the class or function, the script will die with an fatal error (if the class or function was not defined before).

    \lstinputlisting[language=PHP,label=lst:conditionals1,caption=Conditional class and function definitions]{src/php/conditionals1.php}

    Listing \ref{lst:conditionals2} shows when functions and classes will be available.
    If the first call is \texttt{g()} as you can see in \texttt{line 7}, the script will result in a fatal error.
    When \texttt{function f} is executed, \texttt{function g} will be declared, but not yet \texttt{class C}.
    The \texttt{class C} will be declared once \texttt{function g} is executed.
    Once the functions and classes are declared, they are available in the top scope, possibly prefixed with the name of the namespace.
    \lstinputlisting[language=PHP,label=conditionals2,caption=Conditional function declaration]{src/php/conditionals2.php}

    
    \paragraph{Dynamic features}
    PHP comes with dynamic features like: include dynamic variables, dynamic class instantiations, dynamic function calls, dynamic function creation, reflection, and eval.
    A previous study by Mark Hills\cite{Hil:13} has shown that the dynamic features are not used too much.
    %todo (background:dynamic features) check study of mark hills
    Although their are not frequently declared, they can be frequently used.
    Dynamic features are handy to handle the generic case for different variants of an computation, for instance in an abstract class with many descendants.
    Our focus will not be on trying to analyse these features, because we would need constant propagation.
    
    \paragraph{Late static binding}
    Late static binding\footnotemark is implemented in PHP since version 5.3 by adding the keyword \texttt{static} to the language.
    \footnotetext{http://php.net/manual/en/language.oop5.late-static-bindings.php, July 2014}
    It's usage is similar to the keyword \texttt{self}, which refers to the current class. 
    The main difference is that \texttt{self} refers to the class where the code is located, while \texttt{static} refers to the actual instantiated class.
    The keyword \texttt{self} can be easily resolved while \texttt{static} can only be resolved on runtime.
    
    \paragraph{Magic methods}
    In PHP it is allowed to call methods or use properties that do not exists.
    Normally this would result in a fatal error, but not with the use of magic methods.
    One of the magic methods is het constructor method \texttt{\_\_{}call}.
    This method is called when a non-accessible or non-existing method is called.

    \paragraph{Dynamic class properties}
    Although it is a good practice to define your class properties, it is not required to do so in PHP.
    After instantiating a class it is possible to add properties to classes, even without the implementation of magic methods.
    In listing \ref{lst:dynamicProperty} you can see a code sample of adding a property after instantiation of a class.
    The access of the non-existing property \texttt{nonExistingProperty} will result in a warning, but code execution will continue and will just return \texttt{NULL}.
    The code on \texttt{line 4} is where the property is written.
    The object \texttt{\$c} will have the \texttt{nonExistingProperty} publicly available now.
    But in a new class instantiation, like you can see on \texttt{line 6}, will not have the property there.
    
    \lstinputlisting[language=PHP,label=lst:dynamicProperty,caption=Dynamic class property]{src/php/dynamicProperty.php}
    
    \section{Annotations}\label{sec:background_annotations}
    PHP has no native support for annotations.
    But PHP has a \texttt{getDocComment}\footnotemark method in the \texttt{ReflectionClass}. 
    \footnotetext{http://php.net/manual/en/reflectionclass.getdoccomment.php}
    This \texttt{getDocComment} method returns the complete doc block of a certain element as a string.
    A doc block in php has the format \texttt{\slash**...*\slash}.
    Listing \ref{lst:docblock} shows an example of two doc blocks in PHP.
    The first doc block is defined above the class and contains information about the class.
    The second doc block is related to the method \texttt{getSomething}. 
    The block contains a short description of the method, provides type hints for the parameter and the return type, and provides information what exceptions can be thrown by the method. 
    
    
    \lstinputlisting[language=PHP,label=lst:docblock,caption=Examples of PHP DocBlocks]{src/php/docBlock.php}

    Annotations are not part of the official language.
    They are however widely used.
    On one hand for type hinting to help static software analysis.
    On the other hand frameworks like ZEND, Symfony and Doctrine you can write business logic rules in the form of annotations.
    These annotations will be parsed and used in real code.
    These frameworks created their own syntax for annotations.
    \\
    This research will be limited to the first type of annotations which can help developers and IDE's to better understand what the code does.
    For example you can see what kind of input and output is expected for a method.
    Doc blocks with annotations can be placed on top of classes, methods, functions, and variables.
    \\
    Writing annotations is not yet in the PSR standards for PHP, but there is a proposal\footnotemark.
    \footnotetext{https://github.com/php-fig/fig-standards/pull/169/files, July 2014}
    For this research we will only focus on the \texttt{@param}, \texttt{@return}, \texttt{@var}, and \texttt{@inheritDoc} annotations.
    The annotations \texttt{@return} and \texttt{@param} are only useful for functions and class methods. Type hints are described with \texttt{@var} and can be used on all structures, but mainly occur on variables and class fields.
    \\
    There is no official standard for the use of annotations, but most projects follow the phpDocumentor\footnotemark{} syntax.
    \footnotetext{http://www.phpdoc.org/}
    For this research the following annotations are parsed:
    
\begin{equation}
  \begin{aligned}
  \texttt{@return}=\begin{cases}
    \texttt{@return} \; type, & \text{unconditionally read \texttt{@return} $type$}.\\
  \end{cases}
  \end{aligned}
  \phantom{\hspace{8cm}} %%<---adjust the value as you want
\end{equation}

\begin{equation}
  \begin{aligned}
  \texttt{@param}=\begin{cases}
    \texttt{@param} \; type \; \$var, & \text{if `\texttt{@param} $type$ \$var' occurs at least once}.\\
    \texttt{@param} \; \$var \; type, & \text{else if `\texttt{@param} \$var $type$' occurs at least once}.\\
    \texttt{@param} \; type, & \text{otherwise try to match `\texttt{@param} $type$'}.\\
  \end{cases}
  \end{aligned}
  \phantom{\hspace{3.55cm}} %%<---adjust the value as you want
\end{equation}

\begin{equation}
  \begin{aligned}
  \texttt{@var}=\begin{cases}
    \texttt{@var} \; type \; \$var, & \text{if `\texttt{@var} $type$ \$var' occurs at least once}.\\
    \texttt{@var} \; \$var \; type, & \text{else if `\texttt{@var} \$var $type$' occurs at least once}.\\
    \texttt{@var} \; type, & \text{otherwise try to match `\texttt{@var} $type$'}.\\
  \end{cases}
  \end{aligned}
  \phantom{\hspace{3.2cm}} %%<---adjust the value as you want
\end{equation}

\begin{equation}
  \begin{aligned}
  type=\begin{cases}
    type|type, & \text{if `$\vert$' in $type$}.\\
    type, & \text{otherwise}
  \end{cases}
  \end{aligned}
  \phantom{\hspace{8.8cm}} %%<---adjust the value as you want
\end{equation}
	%todo: (background:annotations) explain the used equations above.
 
    \section{Rascal}\label{sec:background_rascal}
    \Gls{Rascal} is a meta programming language developed by Centrum Wiskunde \& Informatica (CWI)\cite{Kli:09}.
    Rascal is designed to analyse, transform and visualise source code.
    The language is build on top of Java and implements various concepts of existing programming languages.
    In this research, besides the modifier PHP-Parser, all of our code is implement in rascal.
    A
    %todo: (background: rascal) explain what rascal is. And how/why we use it in this research

    \section{$M^3$}\label{sec:background_m3}
    The $M^3$-model\cite{Ana:13} is a model which holds information of source code.
    This model is created to analyse one single Java program or compare two or more Java systems with each other.
    The core of the $M^3$-model contains \texttt{containment}, \texttt{declarations}, \texttt{documentation}, \texttt{modifiers}, \texttt{names}, \texttt{types}, \texttt{uses}, \texttt{messages}.
    \\
    The \texttt{declarations} relation contains class, method, variable- information with their logical name and their real location. The type of the relation are \texttt{locations} and represent the logical name of the declaration and will be used in the rest of the $M^3$.
    The \texttt{containment} relation has information on what declarations are contained in each other. For example a package can contain a class; a class can contain fields and methods or an inner class; a method can contain variables.    
    The \texttt{documentation} relation contains all comments from the source code. 
    The \texttt{modifiers} relation has information on the modifiers of declarations. Modifiers are abstract, final, public, protected or private.
    The \texttt{names} relation contains a simplified name of the full declarations.
    The \texttt{types} relation has information about the type of the source code elements.
    The \texttt{uses} relation describes what reference is using which object. For instance when a field of a class is used in some expression, the \texttt{uses} relation links the field in the expression to the declaration of the field in the class.
    And lastly, \texttt{messages} contains errors, warnings or info statements.
    
    \section{Type system}\label{sec:background_type-system}
    The type system defines how rules are applied to types.
    The system determines validates the type usage with type checking.
    The process of actually resolving types is called type inference.
    On one hand the system needs to determine the type of variables, on the other hand it will check the type of the variables.
    \paragraph{Type checking}
    Type checking of dynamic languages differs from static languages.
    In dynamic languages, most type checking is performed during run-time.
    The down side here is that you actually have to run the program to get feedback on incorrect usage of types. 
    For example when you divide an integer by a boolean with value true.
    In PHP these operations are (most of the times) valid and will return you a value.
    In this case, the boolean will be internally concerted to the integer 1.
    This can result in unexpected behaviour and is discouraged to do.
    \\
    On the other hand we have static type systems which allow type checking without executing the code.
    Most analysis can be performed during compile time.
    These systems can catch programming errors related to typing issues and can avoid overhead of runtime type checks.
    In dynamic languages the type checking is done during run time, and this will decrease the performance.
    
    \paragraph{Type inference}
    In the previous section we explained type checking.
    In order to check the types of variables and expression, we need to know the types of variables and expressions first.
    The process of resolving the type of a variable or expressions is called type inference.
    In dynamic languages like PHP it can be difficult to resolve the type of a variable or expression without running the program.
    When you are able to resolve the type before running the program, you are able to optimise the execution code.
    This allows you to make performance improvements or avoid memory usage.
    \\
    In this research we use \textbf{constraint based type inference}.
    Every typeable language construct will have a set of possible types.
    At the start of the analysis every variable and expression will have all possible types, we call this \texttt{Universe}.
    Then we will read all the constraints and will try to solve them.
    Every time a constraint is solved, the number of possible types for one variable will decrease.
    This process will be repeated until we have solved all the constraints and can no longer limit the number of types for a variable.
    This is explained in more details in chapter \ref{sec:research:constraint_solving}.
    \\
    \textbf{$k$ control flow analysis} ($k$-CFA) and \textbf{cartesian product algorithm} (CPA) are two other ways of type inference.
    In $k$-CFA
    %todo (background:k-cfa/cpa) explain K-CFA en CPA
    \\
    The analysis we perform is flow insensitive, which means that we do not analyse the flows of the program.
    We do take the context of the programs into account, making the analysis context sensitive.
    
    \section{Related work}\label{sec:background_related-work}
    %todo (background:related work) describe related work
    Describe these:
    \begin{itemize}
        \item `The HipHop Compiler for PHP'\cite{Zhao:12} (not much information available on their type inference, only source code)
        \item `Phantm: PHP analyzer for type mismatch'\cite{Kne:10,Bar:10} (investigate this in more details, their focus is on finding type errors)
        \item PHPLint \footnotemark (uses a different kind of annotations, not the Java like PhpDocs)
        \item `Soft typing and analyses on PHP programs'\cite{}, code implementations: https://github.com/henkerik/typing and https://github.com/marcelosousa/soft-typing-PHP5 (created for php4, code for php5, should check this out, might be able to compare results with this)
        \item `Design and Implementation of an Ahead-of-Time Compiler for PHP'\cite{Big:10} (to check in detail)
        \footnotetext{http://www.icosaedro.it/phplint, July 2014}
    \end{itemize}
    Also describe their differences with my research.
    
\end{document}