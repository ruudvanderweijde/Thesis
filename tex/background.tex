\documentclass[../main.tex]{subfiles}
\begin{document}
    \chapter{Background and Related Work}\label{ch:background}
    Chapter \ref{ch:background} describes seven important language constructs which the reader needs to understand in order to understand the difficulties of analysing PHP in section \ref{sec:background_language-constructs}.
    The second section, section \ref{sec:background_annotations}, introduces the syntax and usage of annotations in PHP.
    Section \ref{sec:background_rascal} explains \Gls{Rascal}, the programming language used for the analysis.
    In this section we will explain $M^3$, a programming language independent meta model which holds various facts about programs, in more details.
    Section \ref{sec:background_type-system} introduces type systems and how type systems relate to this research.
    The last section of this chapter, section \ref{sec:background_related-work}, describes the related work and how these researches are related to this thesis.

    \section{PHP Language Constructs}\label{sec:background_language-constructs}
    PHP has various language constructs which complicate statical analysis. 
    This section presents language constructs and why these constructs are important for this research.
    Explanations of these constructs help you to understand the performed analysis.
    The discussed parts are scope, file includes, conditional classes and functions, dynamic features, late static binding, magic methods and dynamic class properties.
    
    \paragraph{Scope}
    In PHP, all classes and functions are globally accessible once they are declared.
    All classes and functions are implicitly public, inner classes are not allowed, and conditional functions (see paragraph about conditional classes and functions) will be available in the global scope.
    If a class or function is declared inside a namespace, their name is prefixed with the name of the namespace.
    \\
    Variables have three scope levels: global-, function-, and method-scope.
    Under normal circumstances when a variable is declared inside a function or method, their scope is limited to this function or method.
    Variables declared outside function or methods are available in the global scope, but not in the method or function scope.
    There is an exception for some predefined global variables which are available everywhere. 
    Examples are \texttt{\$GLOBALS}, \texttt{\$\_POST}, and \texttt{\$\_GET}. 
    Variables inside a function or method can be aliased to a global variable by adding the keyword \texttt{GLOBAL} in front of the variable name.
    The variable are then linked to the global variable in the symbol table\footnotemark.
    \footnotetext{http://php.net/manual/en/language.variables.scope.php, July 2014}
    \\
    Closures (anonymous functions in PHP) have the same scoping rules as variables, but they can inherit variables from outside their scope by providing them in the use statement. 
    %In this research we will not support closures. 
    
    \paragraph{Includes}
    PHP allows files to include other PHP-files during execution of the program. 
    The content of these files will be loaded inline. 
    This means that if you use an include in the middle of a file, the source code of this file will be inserted virtually at that place.
    In this research we will not perform an include analysis.
    Instead we will assume that all files in the project are included during execution. 
    %We have checked all projects for duplicate classes and functions but we have found none.
    %Therefor we assume that this does not effect the outcome of the analysis.
    %It is not known if there are effects on inline includes that we do not cover.
    \\
    According to the php coding standard\footnotemark, function- and class-name classes should not appear when using namespaces and autoloading.
    \footnotetext{http://www.php-fig.org/psr/psr-0/, July 2014}
    When a class which is not already loaded in memory, the autoloading function will try to include a file and load the class.
    The structure of the autoloading is meant to include classes, interfaces, traits, and functions and should not have inline code executions which would lead to side-effects.
    
    \paragraph{Conditional classes and functions}
    Once a file is included in the execution, al the classes and functions in the top scope are declared.
    All class and function declarations within condition statements or within a method or function scope are only declared when the code is executed.
    \\
    An example of an conditional statement can be found in listing \ref{lst:conditionals1}.
    If the class \texttt{Foo} or function \texttt{bar} to not exist before the statements is executed, then the class and function will not yet declared. 
    When you try to use the class or function before the code is executed, the script will exit with an fatal error.

    \lstinputlisting[language=PHP,label=lst:conditionals1,caption=Conditional class and function definitions]{src/php/conditionals1.php}

    More examples of dynamic function and class loading is displayed in listing \ref{lst:conditionals2}.
    If the first call is \texttt{g()} as you can see in \texttt{line 8}, the script will result in a fatal error because \texttt{function g()} will only be declared after \texttt{function f()} is executed.
    The \texttt{class C} will be declared once \texttt{function g()} is executed.
    As soon as the functions and classes are declared, they are available in the top scope, possibly prefixed with the name of the namespace they are declared within.
    \lstinputlisting[language=PHP,label=lst:conditionals2,caption=Conditional function declaration]{src/php/conditionals2.php}

    
    \paragraph{Dynamic features}
    PHP comes with dynamic features like: include dynamic variables, dynamic class instantiations, dynamic function calls, dynamic function creation, reflection, and eval.
    These features allow code to change during compile time. 
    New functions and classes can be declared on the fly.
    Method calls, or even whole pieces of code, can be executed based on variable strings.
    \\
    A previous study by Mark Hills\cite{Hil:13} has shown that most real applications make use of dynamic features.
    %todo (background:dynamic features) check study of mark hills
    Dynamic features powerful, but can complicate the statical analysis.
    Additional analysis like constant propagation is needed to resolve most of these dynamic features.
    This is not in scope for this research.
    
    \paragraph{Late static binding}
    Late static binding\footnotemark is implemented in PHP since version 5.3 by adding the keyword \texttt{static} to the language.
    \footnotetext{http://php.net/manual/en/language.oop5.late-static-bindings.php, July 2014}
    It's usage is similar to the keyword \texttt{self}, which refers to the current class. 
    The main difference is that \texttt{self} refers to the class where the code is located, while \texttt{static} refers to the actual instantiated class.
    The keyword \texttt{self} can be easily resolved while \texttt{static} can only be resolved on runtime.
    For the keyword \texttt{self} we will have to refer to the class it's declared in, plus all their descended classes.
    
    \paragraph{Magic methods}
    PHP allows calls and property access on methods and fields that don't exist on a class.
    Normally a call to a non-existing method or property would result in a fatal error, but with the use of magic methods you can specify the wanted behavior.
    Listing \ref{lst:magicMethods} shows an example of the \texttt{\_\_{}call} method.
    This method is triggered when a non-accessible or non-existing method is called.
    In this example the code will try to return the value of a private property based on the provided name.
    The full list of magic methods is \texttt{\_\_{}construct}, \texttt{\_\_{}destruct}, \texttt{\_\_{}call}, \texttt{\_\_{}callStatic}, \texttt{\_\_{}get}, \texttt{\_\_{}set}, \texttt{\_\_{}isset}, \texttt{\_\_{}unset}, \texttt{\_\_{}wakeup}, \texttt{\_\_{}toString}, \texttt{\_\_{}invoke}, \texttt{\_\_{}set\_state}, \texttt{\_\_{}clone}, and \texttt{\_\_{}debugInfo}.
	
	\lstinputlisting[language=PHP,label=lst:magicMethods,caption=Magic methods in PHP]{src/php/magicMethods.php}

    \paragraph{Dynamic class properties}
    Although it is a good practice to define your class properties, it is not required to do so in PHP.
    After instantiating a class it is possible to add properties to classes, even without the implementation of magic methods.
    In listing \ref{lst:dynamicProperty} you can see a code sample of adding a property after instantiation of a class.
    The access of the non-existing property \texttt{nonExistingProperty} will result in a warning, but code execution will continue and will just return \texttt{NULL}.
    The code on \texttt{line 4} is where the property is written.
    The object \texttt{\$c} will have the \texttt{nonExistingProperty} publicly available now.
    But in a new class instantiation, like you can see on \texttt{line 6}, will not have the property there.
    
    \lstinputlisting[language=PHP,label=lst:dynamicProperty,caption=Dynamic class property]{src/php/dynamicProperty.php}
    
    \section{Annotations}\label{sec:background_annotations}
    Annotations are pieces of meta data, defined on class, method, function, or statement level.
    Despite the proposal\footnotemark for official support of annotations, PHP has still no native support them.
    \footnotetext{https://wiki.php.net/rfc/annotations-in-docblock}
    But PHP has a \texttt{getDocComment}\footnotemark method in the \texttt{ReflectionClass} since version 5.1 in 2005. 
    \footnotetext{http://php.net/manual/en/reflectionclass.getdoccomment.php}
    The \texttt{getDocComment} method returns the complete doc block of a certain element as a string.
    A doc block in php has the format \texttt{\slash**...*\slash}.
    Listing \ref{lst:docblock} shows an example of two doc blocks in PHP.
    The first doc block is defined above the class and contains information about the class.
    The second doc block is related to the method \texttt{getSomething}. 
    The block contains a short description of the method, provides type hints for the parameter and the return type, and provides information which possible exceptions can be thrown by the method. 
    
    \lstinputlisting[language=PHP,label=lst:docblock,caption=Examples of PHP DocBlocks]{src/php/docBlock.php}

    Annotations are mainly used for type hinting, documentation, and code execution.
    Software analysis tools and IDE's can use the type hints to aid understanding code and in finding bugs and security issues.
    Available tools can generate documentation based on the doc blocks.
    Programs like Symfony2, ZEND Framework, and Doctrine ORM use annotations for controller routing, templating information, ORM mappings, filters, and validation configuration.
    \\
    This research focusses on the first type of annotations which can help developers and IDE's to better understand how code behaves within a program.
    For example a programmer can see what kind of input and output is expected for a method.
    Doc blocks with annotations can be placed on top of classes, methods, functions, and variables.
    \\
    A standard on using annotations is not in the PHP Standard Recommendations (\gls{PSR}) yet, but there is a proposal\footnotemark.
    \footnotetext{https://github.com/php-fig/fig-standards/pull/169/files, July 2014}
    For this research we will only focus on the \texttt{@param}, \texttt{@return}, \texttt{@var}, and \texttt{@inheritDoc} annotations.
    The annotations \texttt{@return} and \texttt{@param} are only useful for functions, class methods, and closures.
    Type hints are described with \texttt{@var} and can be used on all structures, but mainly occur on variables and class fields.
    \\
    There is no official standard for the use of annotations, but most projects follow the phpDocumentor\footnotemark{} syntax.
    \footnotetext{http://www.phpdoc.org/}
    For this research the following annotations are considered:
    
\begin{equation}
  \begin{aligned}
  \texttt{@return}=\begin{cases}
    \texttt{@return} \; type, & \text{unconditionally read \texttt{@return} $type$}.\\
  \end{cases}
  \end{aligned}
  \phantom{\hspace{8cm}} %%<---adjust the value as you want
\end{equation}

\begin{equation}
  \begin{aligned}
  \texttt{@param}=\begin{cases}
    \texttt{@param} \; type \; \$var, & \text{if `\texttt{@param} $type$ \$var' occurs at least once}.\\
    \texttt{@param} \; \$var \; type, & \text{else if `\texttt{@param} \$var $type$' occurs at least once}.\\
    \texttt{@param} \; type, & \text{otherwise try to match `\texttt{@param} $type$'}.\\
  \end{cases}
  \end{aligned}
  \phantom{\hspace{3.55cm}} %%<---adjust the value as you want
\end{equation}

\begin{equation}
  \begin{aligned}
  \texttt{@var}=\begin{cases}
    \texttt{@var} \; type \; \$var, & \text{if `\texttt{@var} $type$ \$var' occurs at least once}.\\
    \texttt{@var} \; \$var \; type, & \text{else if `\texttt{@var} \$var $type$' occurs at least once}.\\
    \texttt{@var} \; type, & \text{otherwise try to match `\texttt{@var} $type$'}.\\
  \end{cases}
  \end{aligned}
  \phantom{\hspace{3.2cm}} %%<---adjust the value as you want
\end{equation}

\begin{equation}
  \begin{aligned}
  type=\begin{cases}
    type|type, & \text{if `$\vert$' in $type$}.\\
    type, & \text{otherwise}
  \end{cases}
  \end{aligned}
  \phantom{\hspace{8.8cm}} %%<---adjust the value as you want
\end{equation}
	%todo: (background:annotations) explain the used equations above.
 
    \section{Rascal}\label{sec:background_rascal}
    \Gls{Rascal}\cite{Kli:09} is a meta programming language developed by Centrum Wiskunde \& Informatica (CWI).
    Rascal is designed to analyse, transform and visualise source code.
    The language is build on top of Java and implements various concepts of existing programming languages.
    In this research, Rascal is the main programming language.
    The only part that does not use Rascal is the parser of PHP code.
    Although this could be easily implemented in Rascal, there was an existing library written in PHP available.

    \paragraph{}
    $\pmb{M^3}$\cite{Ana:13} is a model which holds various information of source code and is implemented in Rascal.
    % todo explain its general usage
    This model is created to gain insights in the quality of open-source projects.
    For our research we use the $M^3$-model to store facts about the program in a structured way, so we can easily use it at a later stage.
    
    The core element of the $M^3$-model contains \texttt{containment}, \texttt{declarations}, \texttt{documentation}, \texttt{modifiers}, \texttt{names}, \texttt{types}, \texttt{uses}, \texttt{messages}.
    The \texttt{declarations} relation contains class, method, variable- information with their logical name and their real location. The type of the relation are \texttt{locations} and represent the logical name of the declaration and will be used in the rest of the $M^3$.
    The \texttt{containment} relation has information on what declarations are contained in each other. For example a package can contain a class; a class can contain fields and methods or an inner class; a method can contain variables.    
    The \texttt{documentation} relation contains all comments from the source code and its source location.
    The \texttt{modifiers} relation has information on the modifiers of declarations. Modifiers are abstract, final, public, protected, or private.
    The \texttt{names} relation contains a simplified name of the full declarations.
    The \texttt{types} relation has information about the type of the source code elements.
    The \texttt{uses} relation describes what references use an object. For instance when a field of a class is used in some expression, the \texttt{uses} relation links the field in the expression to the declaration of the field in the class.
    And lastly, \texttt{messages} contains errors, warnings, and info statements.
    
    %todo add duck typing as sub part of Type Systems
    \section{Type systems}\label{sec:background_type-system}
    \textbf{Type systems} define how a set of rules are applied to types in their context.
    The system validates the type usage with \textbf{type checking}.
    The process of resolving types is called \textbf{type inference}.
    On one hand the system needs to determine the type of variables, on the other hand it will check the type of the variables.
    
    \paragraph{Type checking}
    Type checking is a mechanism which validates and/or enforces the constraints of a type in their specific context.
    There is a difference between static type checking and dynamic type checking.
    \textbf{Static type checking} is a process of checking the types based on the source code.
    The static type checker will ensure that a program is type safe before executing the program, which means that there will occur no type errors during runtime.
    \textbf{Dynamic type checking} performs the type checking during runtime.
    This means that the program needs to run to gain feedback on the usage of types.
    PHP is a dynamically typed language, which means that there are no types checked before actually running the program.
    There are languages, like JAVA, which have use a combination of static and dynamic type checking.
    The advantage of static type checking is that type errors can be caught early in the development process and allows for compiler optimisations.
    Dynamic type checking systems have more flexibility and allow dynamic loading of new code.
    
    \paragraph{Type inference}
    Type inference is the process of resolving types of variables and expressions.
    The inference process is a prerequisite to be able to perform type checking.
    Being able to infer the type before running the program enables you to optimise code execution by applying compiler optimisations.
    These optimisation allow performance improvements or can optimise memory usage.
    In dynamic languages like PHP it can be difficult to resolve the type of a variable or expression without running the program.
    In statically typed languages, type inference happens at compile time.
    In the next paragraph we will briefly explain some type inference systems.
    \\
    The \textbf{Hindley-Milner}\cite{Hin:69} (HM) type system was found in 1969 by Roger J. Hinldey and almost 10 years later rediscovered\cite{Mil:78} by Robin Milner.
    The first implementation was created four years later by pHd student Luis Damas.
    Damas proved the soundness and completeness of the HM type system with \textbf{Algorithm W}\cite{Dam:82}  in the context of the programming language \texttt{ML}.
    The HM type system deduces the types of the variables to their most abstract type, based on their usage.
    Type declarations and hints are not necessarily to perform type inference.
    The type system is used for various functional languages. 
    \texttt{Haskell} for example uses the Hinley-Milner type system as a foundation for the \texttt{Haskell} type system. 
    \\
    \textbf{Control Flow Analysis}\cite{Nie:99} (CFA) is concerned with resolving sound approximate run-time values at compile time.
    CFA is build on top of data flow analysis\cite{Aho:86} and tries to resolve the control-flow problem.
    One of the earlier CFA algorithms was Shivers' $0$CFA algorithm\cite{Shi:88}, a flow-sensitive constraint based algorithm.
    Shiver then defined $k$-CFA\cite{Shi:91}, where the precision of the analysis is increased by taking the context of the expressions into account.
	\\
    The \textbf{Cartesian Product Algorithm}\cite{Age:95} (CPA) is a type inference algorithm created by Ole Agesen in 1995.
    Agesens work was based on Palsberg and Schwartzbach' \textbf{basic type inference algorithm}\cite{Pal:91}.
    This basic type inference algorithm derives a set of constraints based on \textit{trace graphs} and solves the constraints using a fix-point algorithm.
    Agesen extended the basic algorithm with \textit{templates}.
    These templates are based on control flow and have start and end nodes with their possible in- and outputs.
    The CPA calculates the possibles output types for each template by taking the cartesian product (the set of all possible ordered pairs) of the input types.

    \section{Related work}\label{sec:background_related-work}
    %todo (background:related work) describe related work
    
    Due to the big growth of the internet in the last couple of years, with a big market share of PHP programs, there are numerous people who have analysed PHP programs.
    We will briefly describe a few of them.
    
    \paragraph{}
    Facebook improved the performance of PHP programs with a static compiler, called HipHop Virtual Machine\cite{Zha:12} (HHVM).
    This static compiler extracts the program into an AST, traverses this AST to collect information, performs pre-optimisations, performs type inference, preforms post-optimisations, and lastly generates C++ code.
    During the pre-optimisations the compiler removes unneeded actions, for example constant inlining, logical-expression simplifications, and dead-code elimination.
    The type inference process is based on the Hindley-Milner constraint based algorithm\cite{Dam:82}, to infer types of constants, variables, functions parameters, and return types.
    These new inferred types are then used in the post-optimisation.
    In the last step the AST is traversed to generate C++ code.
    Although the compiler does not cover all functions of PHP, it does covers most of the features.
    The performance benefits on the other hand are significantly better, showing on average 5.5x more effiency.
    
    \paragraph{}
    \texttt{PHANTM}\cite{Kne:10,Bar:10} (PHp ANalyzer for Type Mismatch) is an open source PHP analyser written in Scala.
    Because of PHP's dynamic nature, without compiler or interpreter type checking, it is easy to make typing errors that result in unexpected behaviour or in fatal errors.
    \texttt{PHANTM} performs a hybrid flow-sensitive analysis to find type errors in PHP5.
    The hybrid analysis combines static and dynamic analysis.
    A program can be annotated to start a static analysis at a specific point.
    The analyser collects run-time type information while running the program and then starts the static analysis.
    \texttt{PHANTM} uses data-flow analysis to infer types.
    Although \texttt{PHANTM} has proven to be able to find a number of type errors in three different programs, there is a lack of finding errors in object oriented structures.
    The found errors are found in scalar types.
    
    Describe these:
    \begin{itemize}
        \item PHPLint \footnotemark (uses a different kind of annotations, not the Java like PhpDocs)
        \item `Soft typing and analyses on PHP programs'\cite{}, code implementations: https://github.com/henkerik/typing and https://github.com/marcelosousa/soft-typing-PHP5 (created for php4, code for php5, should check this out, might be able to compare results with this)
        \item `Design and Implementation of an Ahead-of-Time Compiler for PHP'\cite{Big:10} (to check in detail)
        \footnotetext{http://www.icosaedro.it/phplint, July 2014}
    \end{itemize}
    Also describe their differences with my research.
\end{document}