\documentclass[../main.tex]{subfiles}
\begin{document}
    \chapter{Background and related work}\label{chap:background}
    This chapter explains a few language constructs which are important for this research.
    Further more Rascal and M3 will be explained.
    In the last section of this chapter the related work is described.
    
    \section{PHP Language Constructs}\label{sec:PHP_Language_Constructs}
    In this section for this research important language constructs are presented.
    Explanations of these constructs should help to understand the performed analysis.
    %Including some concepts like scope, includes, dynamic variables, dynamic class instantiation, dynamic function call, dynamic dispatch, runtime environment variables and constants, late static binding (static keyword), magic methods.
    
    \paragraph{Scoping}
    In PHP, all classes and functions are globally available once they are declared.
    All classes and functions are implicitly public, inner classes are not allowed, and conditional functions (see paragraph about conditional classes and functions) will be available in the global scope.
    If a class or function is declared inside a namespace, their name will be prefixed with the namespace name.
    Closures (anonymous functions in PHP) have the same scoping rules as variables, but they can use variables from outside closure by providing them in the use statement. In this research we will not support closures because they are fairly new and not much used in practice. 
    \\
    For variables there are three scopes: global-, function-, and method-scope. 
    There is an exception for some global variables which are available everywhere. 
    Examples are \texttt{\$GLOBALS}, \texttt{\$\_POST}, and \texttt{\$\_GET}. 
    Variables inside a function or method can be aliased to a global variable by adding the keyword \texttt{GLOBAL} in front of the variable name.
    The variable will then be linked to the global variable in the symbol table\footnotemark.
    \footnotetext{http://php.net/manual/en/language.variables.scope.php, July 2014}
    
    \paragraph{Includes}
    In PHP it is possible to include other files during execution. 
    These files will be loaded inline, so if you include another file in the middle of the file the code will be inserted virtually at that place.
    Todo here: show the results in some extra section.
    In this research we will assume that all files are loaded.
    We have checked all projects for duplicate classes and functions but we have found none.
    Therefor we assume that this does not effect the outcome of the analysis.
    It is not known if there are effects on inline includes that we do not cover.
    \\
    According to the coding standard that is used in the php community\footnotemark, function- and class-name classes should not appear when using namespaces and autoloading.
    \footnotetext{http://www.php-fig.org/psr/psr-0/, July 2014}
    When a class which is not loaded in memory is instantiated, the autoloading will try to include a file and load the class.
    The structure of the autoloading is meant to include classes, interfaces, traits and functions and should not have inline code executions which would lead to side-effects.
    
    \paragraph{Conditional classes and functions}
    Once a file is included in the execution, al the classes and functions in the top scope are declared.
    All class and function declarations within condition statements or within a method or function scope are only declared when the code is executed.
    \\
    An example of an conditional statement can be found in listing \ref{conditionals1}.
    If the class \texttt{Foo} or function \texttt{bar} to not exist before the statements is executed, then the class and function will not yet declared. 
    When you try to use the class or function, the script will die with an fatal error (if the class or function was not defined before).

    \lstinputlisting[language=PHP,label=conditionals1,caption=Conditional class and function definitions]{src/php/conditionals1.php}

    Listing \ref{conditionals2} shows when functions and classes will be available.
    If the first call is \texttt{g()} as you can see in \texttt{line 7}, the script will result in a fatal error.
    When \texttt{function f} is executed, \texttt{function g} will be declared, but not yet \texttt{class C}.
    The \texttt{class C} will be declared once \texttt{function g} is executed.
    Once the functions and classes are declared, they are available in the top scope, possibly prefixed with the name of the namespace.
    \lstinputlisting[language=PHP,label=conditionals2,caption=Conditional function declaration]{src/php/conditionals2.php}

    
    \paragraph{Dynamic features}
    PHP includes some dynamic features like: include dynamic variables, dynamic class instantiations, dynamic function calls, dynamic function creation, reflection, and eval.
    A previous study by Mark Hills\cite{Hil:13} has shown that the dynamic features are not used too much. (please double check this!!) %todo check this
    Our focus will not be on trying to analyse these features, but we must me aware of these features and should handle them.
    The downside of these dynamic features is that it will probably lower our precision. (please check this) %todo check this
    

    \paragraph{Late static binding}
    Late static binding\footnotemark is implemented in PHP since version 5.3 by adding the keyword \texttt{static} to the language.
    \footnotetext{http://php.net/manual/en/language.oop5.late-static-bindings.php, July 2014}
    It is similar to the keyword \texttt{self}, but it does not refer to the class it is declared in. 
    The main difference is that \texttt{self} can be resolved statically, because it refers to the class it is declared in.
    \texttt{static} can only be resolved on runtime and represents the exact class that is instantiated.
    
    \paragraph{Magic methods}
    In PHP it is allowed to call methods or use properties that do not exists.
    Normally this would result in a fatal error, but not with the use of magic methods.
    One of the magic methods is het constructor method \texttt{\_\_{}call}.
    This method is called when a non-accessible or non-existing method is called.

    \paragraph{Dynamic class properties}
    Although it is a good practice to define your class properties, it is not required.
    On runtime it is possible to add properties to classes, even without the implementation of magic methods.
    In listing \ref{dynamicProperty} you can see a code sample of adding a property after instantiation of a class.
    The acces of the non-existing propery \texttt{nonExistingProperty} will result in a warning, but code execution will continue and will just return \texttt{NULL}.
    The code on \texttt{line 5} is where the property is written.
    The object \texttt{\$c} will have the \texttt{nonExistingProperty} publicly available now.
    But in a new class instantiation, like you can see on \texttt{line 6}, will not have the property there.
    
    \lstinputlisting[language=PHP,label=dynamicProperty,caption=Dynamic class property]{src/php/dynamicProperty.php}

    \paragraph{Annotations}
    In PHP Annotations are not part of the official language.
    They are however widely used. 
    For instance in ZEND, Symfony and Doctrine you can write business logic rules in the form of annotations.
    These annotations will be parsed and used in real code.
    \\
    Other annotations are placed on top of classes, methods, functions, and variables.
    These annotations will help the developers to better understand what the code does. 
    For example you can see what kind of input and output is expected for a method.
    IDE's will also use this information to better analyse the source code.
    \\
    Writing annotations is not yet in the PSR standards for PHP, but there is a proposal\footnotemark.
    \footnotetext{https://github.com/php-fig/fig-standards/pull/169/files, July 2014}
    For this research we will only focus on the \texttt{@param}, \texttt{@return}, \texttt{@var}, and \texttt{@inheritDoc} annotations.
    
    \section{Rascal}
    Explain what \Gls{Rascal} is and what we use it for...
    Some general stuff here.
    This research is performed in a Rascal environment.

    \section{M3}
    In this chapter, only describe what m3 is.
    In some next section I will explain the additional php m3 stuff.
    \\
    But for now (need to create an image of the steps here):
    \begin{itemize}
        \item Parse all files (create \gls{AST}s)
        \item For each file, create an m3 of the ast of the parsed file (aka extract information)
        \item Combine all the m3s
        \item Now run more analysis when all facts are collected in the m3.
        \item Done. M3 is finished! 
    \end{itemize}

    \footnotesize{*Maybe add this section to the next chapter, for the research methods. Many aspects will be useful for the type inference analysis}
    \\
    The M3-model is a generic model which can be used to analyse software programs.
    Our goals is to provide the results in an M3 model.
    Future research can use this to compare different programming languages.
    \\ 
    The following core items are filled for M3:
    \begin{itemize}
        \item Containment
        \item Declarations (need to explain in more details)
        \item Modifiers
        \item Extends
        \item Uses (explain in details what is and what is NOT covered)
    \end{itemize}
    
    The following php specific items are added:
    \begin{itemize}
        \item Extends (class or interface and their extended class or interface)
        \item Implements (which class implements which interfaces)
        \item TraitUses (which class uses which trait)
        \item Parameters (methods and functions and their parameters)
        \item Constructors (which class uses which constructor, explain this more)
        \item Aliases (class aliases, for example the usage of class\_{}alias)
        \item Annotations (contraints annotations on classes, methods, fields and variables)
    \end{itemize}
    Todo, explain in more details...

    
    \section{Related work}
    Describe these:
    \begin{itemize}
        \item `The HipHop Compiler for PHP'\cite{Zhao:12} (not much information available, only source code)
        \item `Phantm: PHP analyzer for type mismatch'\cite{Kne:10,Bar:10} (investigate this in more details, their focus is on finding type errors)
        \item PHPLint \footnotemark (uses a different kind of annotations, not the java like phpdocs)
        \item `Soft typing and analyses on PHP programs'\cite{}, code implementations: https://github.com/henkerik/typing and https://github.com/marcelosousa/soft-typing-PHP5 (created for php4, code for php5, should check this out, might be able to compare results with this)
        \item `Design and Implementation of an Ahead-of-Time Compiler for PHP'\cite{Big:10} (to check in detail)
        \footnotetext{http://www.icosaedro.it/phplint, july 2014}
    \end{itemize}
    Also describe their differences with my research.
    
\end{document}